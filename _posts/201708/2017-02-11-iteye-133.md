---
title: Transaction Attribute
date: 2017-02-11 18:32:31 Z
categories:
- iteye
layout: post
---

        2. Spring Framework 支持的事务属性 1） PROPAGATION_REQUIRED --支持当前的事务，如果不存在就创建一个新的。这是最常用的选择。 2） PROPAGATION_SUPPORTS --支持当前的事务，如果不存在就不使用事务。 3） PROPAGATION_MANDATORY --支持当前的事务，如果不存在就抛出异常。 4）PROPAGATION_REQUIRES_NEW --创建一个新的事务，并暂停当前的事务（如果存在）。 5） PROPAGATION_NOT_SUPPORTED --不使用事务，并暂停当前的事务（如果存在）。 6） PROPAGATION_NEVER --不使用事务，如果当前存在事务就抛出异常。 7） PROPAGATION_NESTED --如果当前存在事务就作为嵌入事务执行，否则与PROPAGATION_REQUIRED类似。     3. 注意事项   1）PROPAGATION_REQUIRES_NEW 与 PROPAGATION_NESTED      PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 "内部" 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行.      另一方面, PROPAGATION_NESTED 开始一个 "嵌套的" 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. Savepoint需要最新的JDBC规范来支持。JDBC3?     由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.   2）Required和mandatory事务属性 一般写操作配置成这两种事务。 两种都支持transaction context. 区别在如果调用时没有transaction context, Required的会发起一个新的事务。而mandatory的会抛出异常。   深层次的区别基于下面的规则： With the exception of the stateful session bean, the method that starts a transaction must be the same method that terminates the transaction.   因为Required不能确认事务是否是在此方法中启动的还是从外面传进来的，因此不知道是否该做rollback这种处理当出现异常时。而Mandatory确认事务都是从外面传入的，因此知道自己不需要处理这种逻辑。   也就是说，如果事务不是在该层发起(客户端发起传入的），那么该层写操作就配置成Mandatory属性，要求调用方必须传入Transaction context；反之事务发起的层写操作应该设成required, 因为它可以控制事务的发起，回滚，提交等。